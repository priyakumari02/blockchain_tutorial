'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _element = require('../element');

var _element2 = _interopRequireDefault(_element);

var _unique = require('../unique');

var _match = require('../match');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = [doOneMatch, doAppropriateMatches, compute].map(_regenerator2.default.mark); /** @jsx createElement */


exports.default = {
  describe: function describe(_ref) {
    var props = _ref.props;

    props = _lodash2.default.defaults({}, props, { strategy: 'start' });
    var trueItems = _lodash2.default.chain(props.items).reject(function (item) {
      return item == null;
    }).map(itemify).value();

    return (0, _element2.default)('raw', {
      func: function func(option) {
        return compute(option.text, trueItems, props);
      },
      limit: props.limit });
  }
};


function itemify(item) {
  var object = _lodash2.default.isString(item) ? { text: item, textLower: _lodash2.default.deburr(item.toLowerCase()) } : _lodash2.default.assign({}, item, { textLower: _lodash2.default.deburr(item.text.toLowerCase()) });
  if (object.qualifier != null) {
    object.qualifiers = [object.qualifier];
  }
  if (object.argument != null) {
    object.arguments = [object.argument];
  }
  if (object.category != null) {
    object.categories = [object.category];
  }
  if (object.annotation != null) {
    object.annotations = [object.annotation];
  }

  return object;
}

function doOneMatch(input, inputLower, items, match, alreadyYieldedIndicies, uniqueSet, unique) {
  var i, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item, uniques, matchObj, _uniques;

  return _regenerator2.default.wrap(function doOneMatch$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          // Need to use for-of so we can use yield, no fun _.forEach here
          i = -1;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 4;
          _iterator = items[Symbol.iterator]();

        case 6:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 30;
            break;
          }

          item = _step.value;

          i++;

          if (!alreadyYieldedIndicies[i]) {
            _context.next = 11;
            break;
          }

          return _context.abrupt('continue', 27);

        case 11:
          if (!unique) {
            _context.next = 15;
            break;
          }

          uniques = unique === 'array' ? item.value : [item.value];

          if (_unique.checkAgainstUniqueSet.apply(undefined, [uniqueSet].concat((0, _toConsumableArray3.default)(uniques)))) {
            _context.next = 15;
            break;
          }

          return _context.abrupt('continue', 27);

        case 15:
          matchObj = match({ input: input, inputLower: inputLower, text: item.text, textLower: item.textLower });

          if (!matchObj) {
            _context.next = 27;
            break;
          }

          matchObj.result = item.value;
          if (item.qualifiers) {
            matchObj.qualifiers = item.qualifiers;
          }
          if (item.categories) {
            matchObj.categories = item.categories;
          }
          if (item.arguments) {
            matchObj.arguments = item.arguments;
          }
          if (item.annotations) {
            matchObj.annotations = item.annotations;
          }
          if (item.data) {
            matchObj.data = item.data;
          }
          alreadyYieldedIndicies[i] = true;
          if (unique) {
            _uniques = unique === 'array' ? item.value : [item.value];

            _unique.addToUniqueSet.apply(undefined, [uniqueSet].concat((0, _toConsumableArray3.default)(_uniques)));
          }
          _context.next = 27;
          return matchObj;

        case 27:
          _iteratorNormalCompletion = true;
          _context.next = 6;
          break;

        case 30:
          _context.next = 36;
          break;

        case 32:
          _context.prev = 32;
          _context.t0 = _context['catch'](4);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 36:
          _context.prev = 36;
          _context.prev = 37;

          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }

        case 39:
          _context.prev = 39;

          if (!_didIteratorError) {
            _context.next = 42;
            break;
          }

          throw _iteratorError;

        case 42:
          return _context.finish(39);

        case 43:
          return _context.finish(36);

        case 44:
        case 'end':
          return _context.stop();
      }
    }
  }, _marked[0], this, [[4, 32, 36, 44], [37,, 39, 43]]);
}

function doAppropriateMatches(input, items, props) {
  var inputLower, alreadyYieldedIndicies, uniqueSet;
  return _regenerator2.default.wrap(function doAppropriateMatches$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          inputLower = _lodash2.default.deburr(input ? input.toLowerCase() : null);
          alreadyYieldedIndicies = [];
          uniqueSet = props.unique ? new Set() : null;
          return _context2.delegateYield(doOneMatch(input, inputLower, items, _match.nullMatch, alreadyYieldedIndicies, uniqueSet, props.unique), 't0', 4);

        case 4:
          return _context2.delegateYield(doOneMatch(input, inputLower, items, _match.beginningMatch, alreadyYieldedIndicies, uniqueSet, props.unique), 't1', 5);

        case 5:
          if (!(props.strategy === 'contain' || props.strategy === 'fuzzy')) {
            _context2.next = 7;
            break;
          }

          return _context2.delegateYield(doOneMatch(input, inputLower, items, _match.anywhereMatch, alreadyYieldedIndicies, uniqueSet, props.unique), 't2', 7);

        case 7:
          if (!(props.strategy === 'fuzzy')) {
            _context2.next = 9;
            break;
          }

          return _context2.delegateYield(doOneMatch(input, inputLower, items, _match.fuzzyMatch, alreadyYieldedIndicies, uniqueSet, props.unique), 't3', 9);

        case 9:
        case 'end':
          return _context2.stop();
      }
    }
  }, _marked[1], this);
}

function compute(input, items, props) {
  var resultIterator;
  return _regenerator2.default.wrap(function compute$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          resultIterator = doAppropriateMatches(input, items, props);
          return _context3.delegateYield(resultIterator, 't0', 2);

        case 2:
        case 'end':
          return _context3.stop();
      }
    }
  }, _marked[2], this);
}