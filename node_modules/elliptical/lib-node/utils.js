'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isComplete = isComplete;
exports.limitIterator = limitIterator;
exports.substrings = substrings;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _smartSplit = require('smart-split');

var _smartSplit2 = _interopRequireDefault(_smartSplit);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isComplete(option) {
  return !_lodash2.default.some(option.words, 'placeholder');
}

// Accepts either an iterator of Options, or an iterator of iterators of Options
function* limitIterator(iterator, limit) {
  if (limit) {
    let successes = 0;
    for (let item of iterator) {
      let success = false;

      if (item[Symbol.iterator]) {
        for (let option of item) {
          const mods = {
            callbacks: option.callbacks.concat(() => {
              success = true;
            })
          };
          yield _lodash2.default.assign({}, option, mods);
        }
      } else {
        const mods = {
          callbacks: item.callbacks.concat(() => {
            success = true;
          })
        };
        yield _lodash2.default.assign({}, item, mods);
      }

      if (success) successes++;
      if (limit <= successes) break;
    }
  } else {
    for (let item of iterator) {
      if (item[Symbol.iterator]) {
        yield* item;
      } else {
        yield item;
      }
    }
  }
}

function* substrings(input, _ref) {
  var _ref$splitOn = _ref.splitOn;
  let splitOn = _ref$splitOn === undefined ? '' : _ref$splitOn;
  var _ref$consumeAll = _ref.consumeAll;
  let consumeAll = _ref$consumeAll === undefined ? false : _ref$consumeAll;
  var _ref$greedy = _ref.greedy;
  let greedy = _ref$greedy === undefined ? false : _ref$greedy;

  if (consumeAll) {
    yield input;
    return;
  }

  let inputs = (0, _smartSplit2.default)(input, splitOn);
  for (let i = 0; i < inputs.length; i += 2) {
    if (greedy) {
      yield inputs.slice(0, inputs.length - i).join('');
    } else {
      yield inputs.slice(0, i + 1).join('');
    }
  }
}