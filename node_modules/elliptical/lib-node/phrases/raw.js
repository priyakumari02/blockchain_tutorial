'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function handleAdditions(output, plural, singular, start, end) {
  const theseAdditions = output[singular] ? [output[singular]] : output[plural];
  if (theseAdditions) {
    return {
      [plural]: _lodash2.default.map(theseAdditions, value => ({ value: value, start: start, end: end }))
    };
  } else {
    return {};
  }
}

function modifyOption(option, rawOutput) {
  const start = option.words.length;
  const words = option.words.concat(rawOutput.words);
  const end = words.length;

  return _lodash2.default.assign({}, option, {
    result: rawOutput.result,
    text: rawOutput.remaining,
    score: rawOutput.score || 1,
    words: words
  }, handleAdditions(rawOutput, 'categories', 'category', start, end), handleAdditions(rawOutput, 'arguments', 'argument', start, end), handleAdditions(rawOutput, 'annotations', 'annotation', start, end), handleAdditions(rawOutput, 'qualifiers', 'qualifier', start, end), rawOutput.data ? { data: _lodash2.default.concat(option.data, [rawOutput.data]) } : {});
}

function* optionsFromRawOutputs(option, rawOutputs) {
  for (let rawOutput of rawOutputs) {
    yield modifyOption(option, rawOutput);
  }
}

function* visit(option, _ref) {
  let props = _ref.props;

  if (!props.func) return;

  const rawOutputs = props.func(option);
  const outputs = optionsFromRawOutputs(option, rawOutputs);

  yield* (0, _utils.limitIterator)(outputs, props.limit);
}

exports.default = { visit: visit };