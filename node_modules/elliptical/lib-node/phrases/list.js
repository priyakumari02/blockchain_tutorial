'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _element = require('../element');

var _element2 = _interopRequireDefault(_element);

var _unique = require('../unique');

var _match = require('../match');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } } /** @jsx createElement */


exports.default = {
  describe: function describe(_ref) {
    let props = _ref.props;

    props = _lodash2.default.defaults({}, props, { strategy: 'start' });
    const trueItems = _lodash2.default.chain(props.items).reject(item => item == null).map(itemify).value();

    return (0, _element2.default)('raw', {
      func: option => compute(option.text, trueItems, props),
      limit: props.limit });
  }
};


function itemify(item) {
  const object = _lodash2.default.isString(item) ? { text: item, textLower: _lodash2.default.deburr(item.toLowerCase()) } : _lodash2.default.assign({}, item, { textLower: _lodash2.default.deburr(item.text.toLowerCase()) });
  if (object.qualifier != null) {
    object.qualifiers = [object.qualifier];
  }
  if (object.argument != null) {
    object.arguments = [object.argument];
  }
  if (object.category != null) {
    object.categories = [object.category];
  }
  if (object.annotation != null) {
    object.annotations = [object.annotation];
  }

  return object;
}

function* doOneMatch(input, inputLower, items, match, alreadyYieldedIndicies, uniqueSet, unique) {
  // Need to use for-of so we can use yield, no fun _.forEach here
  let i = -1;
  for (let item of items) {
    i++;
    if (alreadyYieldedIndicies[i]) {
      continue;
    }
    if (unique) {
      const uniques = unique === 'array' ? item.value : [item.value];
      if (!_unique.checkAgainstUniqueSet.apply(undefined, [uniqueSet].concat(_toConsumableArray(uniques)))) {
        continue;
      }
    }

    const matchObj = match({ input: input, inputLower: inputLower, text: item.text, textLower: item.textLower });
    if (matchObj) {
      matchObj.result = item.value;
      if (item.qualifiers) {
        matchObj.qualifiers = item.qualifiers;
      }
      if (item.categories) {
        matchObj.categories = item.categories;
      }
      if (item.arguments) {
        matchObj.arguments = item.arguments;
      }
      if (item.annotations) {
        matchObj.annotations = item.annotations;
      }
      if (item.data) {
        matchObj.data = item.data;
      }
      alreadyYieldedIndicies[i] = true;
      if (unique) {
        const uniques = unique === 'array' ? item.value : [item.value];
        _unique.addToUniqueSet.apply(undefined, [uniqueSet].concat(_toConsumableArray(uniques)));
      }
      yield matchObj;
    }
  }
}

function* doAppropriateMatches(input, items, props) {
  const inputLower = _lodash2.default.deburr(input ? input.toLowerCase() : null);

  const alreadyYieldedIndicies = [];
  const uniqueSet = props.unique ? new Set() : null;
  yield* doOneMatch(input, inputLower, items, _match.nullMatch, alreadyYieldedIndicies, uniqueSet, props.unique);
  yield* doOneMatch(input, inputLower, items, _match.beginningMatch, alreadyYieldedIndicies, uniqueSet, props.unique);

  if (props.strategy === 'contain' || props.strategy === 'fuzzy') {
    yield* doOneMatch(input, inputLower, items, _match.anywhereMatch, alreadyYieldedIndicies, uniqueSet, props.unique);
  }

  if (props.strategy === 'fuzzy') {
    yield* doOneMatch(input, inputLower, items, _match.fuzzyMatch, alreadyYieldedIndicies, uniqueSet, props.unique);
  }
}

function* compute(input, items, props) {
  const resultIterator = doAppropriateMatches(input, items, props);
  yield* resultIterator;
}